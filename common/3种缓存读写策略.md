### 总述

常用的3种缓存读写策略如下：

- Cache Aside Pattern（旁路缓存模式）

- Read/Write Through Pattern（读写穿透）

- Write Behind Pattern（异步缓存写入）

### Cache Aside Pattern（旁路缓存模式）

使用的比较多的策略，适合于读多写少的场景，读写的操作如下：

- 读：从Redis中读数据，如果读取到则返回；如果读取不到数据，则读DB，然后将读到的数据写到Redis中
- 写：更新DB，然后删除Redis中的缓存数据

这儿可以发现对于写和读的操作，都存在两个子过程，包括操作Redis和操作Mysql，下面说的读操作都是说Redis中读取不到数据。

对于读操作，先读DB，再写Redis，这儿有两个操作。

对于写操作，先写DB，在删除Redis，这儿也有两个操作。

对于并发场景，读写并存，读写操作都不可能是原子操作，因此存在数据不一致的情况，不过概率比较下，比如下面的情况：

请求1读DB ->请求2写DB -> 请求2删Redis -> 请求1写Redis

这种情况的概率是比较小的，因为写DB总是耗时比较久的，而操作Redis总是快速的，因此通常的情况是请求1写完Redis后，才轮到请求2删Redis数据。

#### 缺陷

##### 问题1：首次请求的数据肯定不在Redis中

解决方法：可以将热点数据提前放置在Redis中

##### 问题2：写操作比较多的场景，会导致大量的删除Redis中的数据，从而缓存命中率很低

解决方法：

1. 数据库和缓存数据强一致场景 ：更新 DB 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。
2. 可以短暂地允许数据库和缓存数据不一致的场景 ：更新 DB 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。



### Read/Write Through Pattern（读写穿透）

通常来说我们将DB作为主要的数据存储，这个策略将Redis作为主要存储，从Redis中读取数据并且写数据也是写Redis，由Redis来和DB进行数据的交互，从而减轻应用程序的职责

策略的读写操作如下：

读操作：从Redis中读取数据，有则返回；无则Redis从DB获取，然后给返回给应用程序

写操作：应用程序写数据到Redis，由Redis写数据到DB中（同步），然后给应用程序返回操作结果

### Write Behind Pattern（异步缓存写入）

和Read/Write Through Pattern类似，区别主要是对于写操作，Read/Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。

优势：Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景