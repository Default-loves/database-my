### 全局锁、表级锁、行锁

#### 全局锁

全局锁的使用场景主要是为了做全库逻辑备份

使用命令`Flush tables with read lock(FTWRL)`，让库处于只读的状态，其他修改操作将会被阻塞

而对于使用InnoDB引擎的表，建议使用`mysqldump`，使用参数`-single-transaction`，在导数据前会启动一个事务，来确保拿到一致性视图，由于MVCC的支持，该过程中数据是可以正常更新的

避免通过`set global readonly=true`，设置全局只读来设置，原因主要是当出现异常的时候，FTWRL会自动释放全局锁，恢复到可用状态，而设置全局只读还需要手工设置，导致库较长时间处于不可写的状态；其次，这个值可能会被用来进行逻辑判断，比如判断是从库还是主库，修改则影响范围较大。

#### 表级锁

MySql表级锁有两种，一种是表锁，一种是元数据锁。通常来说我们比较少用表级锁，毕竟锁整个表代价比较高，而建议使用行锁

##### 表锁

表锁的语法是`lock table T read/write`，

##### 元数据锁（meta data lock, MDL）

元数据锁不需要显示使用，在访问表的时候会自动加上，对表做增删改查的时候会加上MDL读锁，对表做结构变更的时候会加上MDL写锁，事务提交的时候才会释放锁

例子：给表加字段导致表不可读写

客户端A开启事务对表格增删改查，这儿获取的是MDL读锁。客户端B开启事务对表格查询，这儿获取的也是MDL读锁，可以正常执行。客户端C给表加字段，此时需要获取MDL写锁，不过由于A和B的MDL读锁还没有释放，所以C会被阻塞。

后续如果还有客户端D需要对表进行查询，由于获取不到MDL读锁（因为C持有MDL写锁），D也阻塞了，至此，表格不可读也不可写。而且如果客户端有超时重试，后续会有大量的线程阻塞

如何安全地给表加字段？

> 首先检查是否有长事务，保证没有长事务存在，其次，对SQL语句设置等待时间，超过等待时间则放弃，不要阻塞后面的语句，通过重复执行SQL语句来实现增加字段，具体可以使用下面的语句：
>
> ALTER TABLE T NOWAIT add column ...
>
> ALTER TABLE T WAIT N add column ...

#### 行锁

MyISAM不支持行锁，InnoDB支持。行锁是在需要的时候才加上去的（不是在事务开始begin就加行锁，而是在update等语句执行前才加行锁），但是直到事务结束后才释放，这是两阶段锁协议，因此如果事务需要锁多各行，把最可能造成锁冲突的，最可能影响并发度的数据更新操作放到最后

行锁的实现？

> innodb行锁是通过锁索引记录来实现的，如果更新的列没有建立索引是会对扫描的数据逐行加锁的

当出现死锁的时候处理？

> 设置`innodb_lock_wait_timeout`，表示一个事务执行时间超过阈值，则将事务回滚。需要注意的是，这种方式可能误杀确实需要较长执行时间的长事务
>
> 参数`innodb_deadlock_detect`一般设置为`on`，表示开启死锁检测功能，发现死锁后，主动回滚其中的一条事务，让其他事务得以执行

在高并发量的情况下，即有大量的请求同时更新同一行，死锁检测需要耗费大量的CPU资源，对于性能问题解决如下

> 1. 如果能够确保业务中一定不会出现死锁，那么可以临时把死锁检测给关掉，但是存在风险
> 2. 在数据库服务端控制并发量，在中间件或者MySQL中（需要修改mysql源码），对于相同行的更新，在进入引擎之前排队，这样在InnoDb内部就不会有大量的死锁检测工作。
> 3. 将更新一行的逻辑变为多行，比如更新1行数据变为更新10行中的随机一行，这样将冲突概率变为原来的1/10,，需要根据业务逻辑做详细设计，获取数据的时候，要累计10行的数据，而且当某一部分记录超出临界值（比如0）的时候需要做特殊处理

### 查看锁信息

```mysql
select * from information_schema.INNODB_LOCK_WAITS;
select * from information_schema.INNODB_LOCKS;
```



### 排它锁和共享锁

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
- 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

```text
select ... lock in share mode //共享锁 
select ... for update //排他锁 
```

**select for update：**在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。

使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。

**select lock in share mode ：**in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。

使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。