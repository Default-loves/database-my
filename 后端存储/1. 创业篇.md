## 总览

- 创业篇，我们重点解决从 0 到 1 的问题；比如：如何低成本高质量地快速构建一个小规模的订单存储系统。

- 高速增长篇，我们关注在高速变化的过程中，你的系统一定会遇到的一些共通问题，以及该如何应对这些问题。比如说，如何从单机的存储系统逐步演进为分布式存储系统；如何在线平滑的扩容我们的存储系统。

- 海量数据篇，我们重点解决高并发、海量数据情况下的存储系统该如何设计的问题。比如，海量的埋点数据该怎么存储；如何在各种数据库之间实时迁移和同步海量数据，等等。



## 设计电商系统

1. 确定使用系统的人员：老板，顾客，商家
2. 确定使用人员需要的功能
   - 老板：查看报表
   - 顾客：浏览、购物
   - 商家：上架货物，管理库存，发货

这个时候可以绘制第一个UML图——用例图

![image](F:\blog\后端存储\pic\用例图.jpg)

确定最主要的业务流程——购物流程，根据流程来划分功能模块，使用UML的时序图

![](F:\blog\后端存储\pic\时序图.jpg)

然后分析其他的业务流程，可以总结出电商系统主要的十大功能模块，商品、订单、购物车、支付、库存、促销、用户、账户、搜索推荐和报表。

商品：维护和展示商品信息和价格。

订单：维护订单信息和订单状态，计算订单金额。

购物车：维护用户购物车中的商品。

支付：负责与系统内外部的支付渠道对接，实现支付功能。

库存：维护商品的库存数量和库存信息。

促销：制定促销规则，计算促销优惠。

用户：维护系统的用户信息，注意用户模块它是一个业务模块，一般不负责用户登录和认证，这是两个完全不同的功能。

账户：负责维护用户的账户余额。

搜索推荐：负责商城中，搜索商品和各种列表页和促销页的组织和展示，简单的说就是决定让用户优先看到哪些商品。

报表：实现统计和分析功能，生成报表，给老板来做经营分析和决策使用。



## 创业篇

### 创建和更新订单，保证数据准确

- 避免客户重复下单，需要订单服务具备幂等性。给订单系统添加一个“生成订单号”的服务，每次客户在进入结算页面的时候生成唯一订单号，在提交订单的时候从前端发送订单号给后端，后端数据库使用订单号作为订单表的主键，使用数据库的唯一索引来放置重复下单

- 避免ABA问题。通过在订单表增加一列“版本”属性，每次更新数据后将数据版本+1，而且，比较版本号、更新数据和版本号更新，需要在一个事务中完成，可以使用如下的SQL语句作为模板

```mysql
UPDATE orders set state = 666, version = version+1
WHERE version = 8;
```



### 商品详情页

商品详情页的内容包括商品基本信息，商品参数信息，图片视频，价格和优惠等

- 商品基本信息：包括标题副标题，价格，颜色等，都具有固定的属性，保存在MySQL中
- 商品参数信息：由于每个商品对应的参数都是不一样的，比如电脑的参数都是重量，形状，内存磁盘型号等，而像化妆品则是成分，品牌等，适合用MongoDB来存储
- 图片视频：使用对象存储云服务，几乎所有的对象存储云服务都自带CDN加速服务，响应时间做了很多优化，可以在较短的时间内进行响应

需要保存商品的每个历史版本，放置到历史商品表中，目的是为了从订单表可以查看到历史的商品详情页

由于商品详情页并发量很大，而且访问量也很大，所以对于商品介绍适合做成静态页面，避免每次请求页面的时候全部内容都动态生成，商品详情页静态化后，不仅可以节省服务器资源，而且可以利用CDN加速，将商品详情页放置到离用户比较近的CDN服务器，加速访问速度

而价格，促销信息等经常变动的信息，则可以在前端页面使用AJAX请求后端服务动态获取

![project](1. 创业篇.assets/project.png)

### 购物车

- 用户未登录时，需要将商品放置到“临时购物车”中
- 用户登陆后，需要将临时购物车中的商品放置到“购物车”中，并且清空临时购物车

临时购物车需要放置在客户端，而不是服务器上，可以选择的有Session、Cookie，LocalStorage

- Session保留时间短，而且本质上是保存在服务器的，不使用
- Cookie：客户端和服务端的每次交互，都会携带Cookie信息，服务端可以读取Cookie的信息，因此业务逻辑可以全部放置在服务端
- LocalStorage：只能由客户端来访问，所以实现来说会复杂一些，因为需要在客户端和服务端都实现业务逻辑，不过其存储容量比Cookie大得多

使用Redis还是MySQL来存储？

- 响应速度：Redis当然是最快
- 可靠性：MySQL最好
- 可扩展性：MySQL最好



### 使用事务保证账户余额正确

账户系统需要记录每次交易的详情（流水），关于流水有几条重要的原则：

1. 账户流水只能新增，不能修改或者删除
2. 流水号必须是递增的，从而确定交易的先后顺序

一种可行的，安全的交易实现如下，在事务隔离级别是RC和RR都可以

1. 我们给账户余额表增加一个 log_id 属性，记录最后一笔交易的流水号。
2. 首先开启事务，查询并记录当前账户的余额和最后一笔交易的流水号。
3. 然后写入流水记录。
4. 再更新账户余额，需要在更新语句的 WHERE 条件中限定，只有流水号等于之前查询出的流水号时才更新。
5. 然后检查更新余额的返回值，如果更新成功就提交事务，否则回滚事务。



### 分布式事务，保证多个系统数据一致性

分布式事务的解决方案有：2PC，3PC，TCC，本地消息表等

#### 2PC

客户端请求服务，将请求发送给协调者，协调者分别向服务A和服务B发送“准备”的命令，协调者等待服务A和服务B都准备完毕后，分别向两个服务发送”提交“命令，服务A和服务B提交完成后发送”完成“命令给协调者，协调者发送”完成“命令给客户端

协调者可以由其中一个服务担任，可以减少调用时间

如果“准备”阶段有问题，协调者会向服务A和服务B发送“回滚”命令

在协调者发送“提交”命令之后，如果由于网络原因服务没有接收到“提交”命令，此时分布式事务只能成功，不能失败，所以需要进行多次重试

性能比较差，实现的是强一致性，适合并发量不大的场景

#### 本地消息表

服务A完成自身的服务后，将需要服务B完成的命令插入到本地的消息表中，此时，可以向客户端发送“完成”命令，由异步线程读取本地消息表进行服务B的请求

异步执行的服务不能有依赖的资源，比如下单锁定库存这个操作，如果锁定库存异步操作，会导致如果没有库存导致锁定失败，但是下单的时候却给客户端返回了成功消息

实现的是最终一致性，性能很好，实现简单，适合大多数场景



### Elasticsearch构建搜索服务

用 ES 构建商品搜索服务的这个过程：

首先安装 ES 并启动服务，然后创建一个 INDEX，定义 MAPPING，写入数据后，执行查询并返回查询结果



### 数据备份和恢复

- 全量备份数据库`test`：`$mysqldump -uroot -p test > test.sql`
- 恢复数据库`test`：`$mysql -uroot test < test.sql`

全量备份会导致锁表，数据量很大，极大耗费服务器资源，因此需要结合增量备份，对于mysql其自带了binlog，会记录数据库的所有操作，并且可以重放，可以恢复数据

首先需要开启binlog，可以通过下面语句查看是否开启

```mysql

mysql> show variables like '%log_bin%';
+---------------------------------+-----------------------------------+
| Variable_name                   | Value                             |
+---------------------------------+-----------------------------------+
| log_bin                         | ON                                |
| log_bin_basename                | /usr/local/var/mysql/binlog       |
+---------------------------------+-----------------------------------+
mysql> show master status;
+---------------+----------+--------------+------------------+-------------------+
| File          | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+---------------+----------+--------------+------------------+-------------------+
| binlog.000001 |    18745 |              |                  |                   |
+---------------+----------+--------------+------------------+-------------------+
```

数据恢复的操作可以如下：

```mysql
$mysql -uroot test < dump.sql


$mysqlbinlog --start-datetime "2020-02-20 00:00:00" --stop-datetime "2020-02-20 15:09:00" /usr/local/var/mysql/binlog.000001 | mysql -uroot


mysql> select * from  account_balance;
+---------+---------+---------------------+--------+
| user_id | balance | timestamp           | log_id |
+---------+---------+---------------------+--------+
|       0 |     200 | 2020-02-20 15:08:12 |      0 |
+---------+---------+---------------------+--------+
```

通过配置binlog的格式为ROW，可以保证重放的时候是幂等的，因此在指定binlog重放的开始时间可以比全量备份的时间稍微早一点，确保数据的完整性。



### MySQL高可用方案

MySQL高可用方案，也叫作MySQL HA，可以有以下三个方案：

|             方案             | 高可用 | 可能丢失数据 | 性能 |
| :--------------------------: | :----: | :----------: | :--: |
| 一主一从，异步复制，手动切换 |   否   |     可控     |  好  |
| 一主一从，异步复制，自动切换 |   是   |      是      |  好  |
| 一主两从，同步复制，自动切换 |   是   |      否      |  差  |





- 

